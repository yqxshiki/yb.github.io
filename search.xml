<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生JS实现回到顶部动画]]></title>
    <url>%2Fyqxshiki.github.io%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[点击按钮回到页面顶部这是个在日常开发中经常用的效果，今天，就用原生Javascript来实现 1234567891011121314151617&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .top &#123; width: 300px; height: 300px; background: #f40; line-height: 300px; cursor: pointer; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class="top"&gt;&lt;/div&gt; &lt;/body&gt; 12345678910111213141516171819let divtop = document.getElementsByClassName("top")[0] divtop.addEventListener("click", function () &#123; let timer = setInterval(() =&gt; &#123; // 获取滚动条高度 let wTop = document.documentElement.scrollTop || document.body.scrollTop; // 上升速度 let speed = Math.floor(-wTop / 5) // 上升过程中逐步获取滚动条高度 document.documentElement.scrollTop = document.body.scrollTop = wTop + speed; // 到顶部时.停止 if (wTop === 0) &#123; clearInterval(timer) &#125; &#125;, 30) &#125;)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs实现github第三方登录]]></title>
    <url>%2Fyqxshiki.github.io%2FNodejs%E5%AE%9E%E7%8E%B0github%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95.html</url>
    <content type="text"><![CDATA[第三方登录在日常开发中是经常被使用的,我在做个人博客时,因为要做评论功能,又考虑到不能和别人做到良好的沟通交流，所有研究了一下第三方登录,这里使用github为例,其他都差不多,如果你发现我的文章有什么问题或者错误,欢迎在我的博客里面评论. 本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 实现流程 github-API文档 Github配置登录github，点击setting，点击Developer settings 点击到OAuth Apps 配置授权页面，注册授权信息 前端代码12345&lt;body&gt; &lt;div class="wrap"&gt; &lt;a href="http://localhost:3000/github/login"&gt;github登录&lt;/a&gt; &lt;/div&gt;&lt;/body&gt; 后端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const express = require("express")const app = express();const axios = require("axios")const querystring = require("querystring")app.use(require("cors")())app.use(express.json())// github配置参数const config = &#123; _id: "xxxxxxxxxxxxxxxxxxx", _secret: "xxxxxxxxxxxxxxxxxxx"&#125;app.get("/", async (req, res) =&gt; &#123; res.send("ok")&#125;)// 登录app.get("/github/login", async (req, res) =&gt; &#123; // 请求用户的GitHub身份 let path = 'https://github.com/login/oauth/authorize?client_id=' + config._id // 重定向到github登录页 res.redirect(path)&#125;)//回调app.get("/callback", async (req, res) =&gt; &#123; //如果用户接受您的请求，则GitHub会code使用代码参数中的临时值重定向到您的站点。临时代码将在10分钟后过期。 let code = req.query.code; // 需要配置的参数 const params = &#123; client_id: config._id,//您从GitHub收到的GitHub App的客户密码。 client_secret: config._secret,//您从GitHub收到的GitHub App的客户密码。 code: code//您收到的作为对步骤1的响应的代码。 &#125; let data = await axios.post("https://github.com/login/oauth/access_token", params); // 例如data.data 的值access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer // 从github获得的access_token进行截取 const access_token = querystring.parse(data.data).access_token; //截取后 data.data 的值access_token=e72e16c7e42f292c6912e7710c838347ae178b4a // 获取用户信息 data = await axios.get('https://api.github.com/user?access_token=' + access_token) res.send(data.data)&#125;)app.listen(3000, () =&gt; &#123; console.log(`http://localhost:3000`)&#125;)]]></content>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nuxtjs设置环境变量]]></title>
    <url>%2Fyqxshiki.github.io%2Fnuxtjs%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html</url>
    <content type="text"><![CDATA[Nuxt.js 本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 安装cross-env1npm i cross-env -D env.js文件在项目的根目录创建 12345678910module.exports = &#123; dev: &#123; MODE: 'development', ENV_API: "xxxxxx" //开发环境 &#125;, pro: &#123; MODE: 'production', ENV_API: 'xxxxxx' //生产环境 &#125;&#125; nuxt.config.js配置123456const env = require("./env")export default &#123; env: &#123; baseUrl: env[process.env.MODE].ENV_API &#125;, package.json 配置12345678910在这里使用之前安装的cross-env这个包&#123; "scripts": &#123; "dev": "cross-env MODE=dev nuxt", "build": "cross-env MODE=pro nuxt build", "start": "cross-env MODE=pro nuxt start", "generate": "cross-env MODE=pro nuxt generate", "analyze": "nuxt build --analyze" &#125;,&#125; 使用方法现在就非常简单了，比如我们刚刚在nuxt.config.js中定义了baseUrl，可以直接process.env.baseUrl调用]]></content>
      <categories>
        <category>web前端</category>
        <category>SSR(服务器渲染)</category>
      </categories>
      <tags>
        <tag>Nuxtjs</tag>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuelazyload实现图片懒加载]]></title>
    <url>%2Fyqxshiki.github.io%2Fvuelazyload.html</url>
    <content type="text"><![CDATA[在web前端中，性能优化是一个大问题，而图片懒加载就是其中一个比较重要的环节，现在在项目中，我们可以使用vue-ladyload来实现. 本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 CDN方式使用123456&lt;script src=&quot;https://unpkg.com/vue-lazyload/vue-lazyload.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.use(VueLazyload) ...&lt;/script&gt; NPM使用1npm i vue-lazyload 新建文件vuelazyload.js123456789import VueLazyLoad from 'vue-lazyload'import Vue from 'vue'Vue.use(VueLazyLoad, &#123; error: require("../static/error.jpg"), //错误图片 loading: require('../static/loading.gif'), //加载图片 attempt: 2 //尝试次数&#125;) 使用模板12345// 使用前&lt;img :src="item.icon" alt /&gt;// 使用后&lt;img v-lazy="item.icon" alt /&gt; 更多的配置信息在 npm地址]]></content>
      <categories>
        <category>web前端</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs的通用接口]]></title>
    <url>%2Fyqxshiki.github.io%2FNodejs%E7%9A%84%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3.html</url>
    <content type="text"><![CDATA[在正常开发中，我们经常实现一个数据的增删改查，这样在后端我们需要根据一个数据创建四个接口，如果数据过多，就会有好多的冗余代码. 本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 使用express创建服务器12345678910111213141516const express = require('express')const app = express()// 解析jsonapp.use(express.json())//解决跨域app.use(require('cors')())// 数据库require('./plugins/db')(app)// 路由require('./routes/admin/index')(app)app.listen(4000, () =&gt; console.log('app listening on port 4000!')) 连接Mongodb数据库123456789module.exports = app =&gt; &#123; const mongoose = require("mongoose") mongoose.connect('mongodb://localhost:27017/blog', &#123; useCreateIndex: true, useFindAndModify: true, useNewUrlParser: true, useUnifiedTopology: true &#125;)&#125; routes 接口展示123456789101112131415161718192021222324252627282930313233343536373839module.exports = app =&gt; &#123; const express = require("express") const router = express.Router(&#123; mergeParams: true &#125;) // 增 router.post('/add', async (req, res) =&gt; &#123; const data = await req.Model.create(req.body); res.send(data) &#125;) //删 router.delete('/delete/:id', async (req, res) =&gt; &#123; const data = await req.Model.findByIdAndDelete(req.params.id); res.send(&#123; status: true &#125;) &#125;) // 改 router.post("/resive/:id", async (req, res) =&gt; &#123; const data = await req.Model.findByIdAndUpdate(req.params.id, req.body); res.send(data) &#125;) // 查 router.get("/check", async (req, res) =&gt; &#123; const data = await req.Model.find(); res.send(data); &#125;) app.use("/api/rest/:resource",async(req,res,next)=&gt;&#123; //将接口名变为模型的文件名 例如:/api/rest/categoies 模型名就必须是Category const modelname=require('inflection').classify(req.params.resource) //models 里面是模型 req.Model=require(`../models/$&#123;modelname&#125;`) await next(); &#125;,router) &#125;]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB的常用使用方式]]></title>
    <url>%2Fyqxshiki.github.io%2FMongoDB.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 mongoDB官网点击进入 Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具 mongoose文档点击进入 mongoose安装1npm i mongoose --save mongoose使用1234567891011121314151617181920212223242526272829//引入mongooseconst mongoose = require('mongoose');//连接数据库，就算没有这个数据库也会创建这个数据库mongoose.connect("mongodb://localhost:27017/mongoose_test", &#123; useNewUrlParser: true, useUnifiedTopology: true&#125;)// 监听数据库mongoose.connection.once('open', (err) =&gt; &#123; if (!err) &#123; console.log("连接成功····") &#125;&#125;)//定义Schema，每个 schema 都会映射到一个 MongoDB collection ，并定义这个collection里的文档的构成。const Schema = mongoose.Schema;let ArticleSchema = new Schema(&#123; title: &#123; type: String &#125;, body: &#123; type: String &#125;,&#125;)// 定义一个模型let Article = mongoose.model('Articles', ArticleSchema) 增12345678910111213141516app.get("/add", async (req, res) =&gt; &#123; let arr = await Article.create([&#123; title: "第一篇文章", body: "第一篇内容" &#125;, &#123; title: "第二篇文章", body: "第二篇内容" &#125;, &#123; title: "第三篇文章", body: "第三篇内容" &#125; ]) res.send(arr);&#125;) 查123456789app.get("/find", async (req, res) =&gt; &#123; // 查询所有 let arr = await Article.find(); // 查询满足要求的第一个 // let arr = await Article.findone(&#123; // title: "第一篇文章" // &#125;) res.send(arr);&#125;) 改12345678app.post("/put", async (req, res) =&gt; &#123; // updateOne 改一个 // updateMany 改多个,使用数组 let arr = await Article.updateOne(&#123; title: "第三篇文章" &#125;, req.body) res.send(arr);&#125;) 删app.delete("/delete", async (req, res) =&gt; { // remove 结合体，都可以 // deleteOne 删一个 // deleteMany 删多个,使用数组 let arr = await Article.remove({ title: "第二篇文章" }) res.send(arr); }) `` **持续更新中**]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>mongoose</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-music 仿网易云移动端]]></title>
    <url>%2Fyqxshiki.github.io%2FVuemusic.html</url>
    <content type="text"><![CDATA[music在做完vue-admin-webapp后,看到了好多仿网易云的项目,我也想自己做一个，满足一下自己的虚荣心，自己用自己做的项目听歌。本项目是一个移动端项目,采用Vant框架,当然还有许多的移动端框架可以选择。这个就看自己或者团队了. 在这里面要感谢binaryify大佬的网易云api NeteaseCloudMusicApi 本人Blog(国内)点击进入 本人Blog(国外)点击进入 项目运行地址点击进入 github地址点击进入 如果你觉得还行,希望你给我点个star 本项目使用的技术栈是: Vue 3.10.0 animate 3.7.2 axios vant vue-router 3.10.0 vuex 3.10.0 移动端布局 flex rem 后端接口都是使用的NeteaseCloudMusicApi里面的api 目录结构整个文件的目录结构 12345678910111213141516171819202122232425262728├── public # 静态资源│ ├── favicon.ico # favicon图标│ └── index.html # html模板├── src # 源代码│ ├── assets # 图片、字体等静态资源| ├── components # 组件| │ ├── about # 关于页面| │ ├── Common # 全局公用组件| │ ├── Gedan # 歌单| │ ├── Login # 登录注册| │ ├── Popup # 侧边栏和播放列表栏| │ ├── Ranking # 排行榜| │ ├── Search # 搜索| │ ├── Singer # 歌手信息| │ ├── User # 用户信息| │ ├── Error.uve # 404| │ ├── Footer.vue # 底部栏| │ ├── Header.vue # 顶部| │ ├── Home.js # 入口页面| ├── App.vue # 入口页面| ├── main.js # 入口文件 加载组件 初始化等| ├── router.js # 路由| ├── store.js # vuex├── .gitignore.js # git忽略文件设置├── babelrc.config.js # babel-loader 配置├── package.json # package.json├── postcss.config.js # postcss 配置└── vue.config.js # vue-cli 配置 页面展示&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195; &#8195;&#8195;&#8195;&#8195;&#8195; 在多个组件内部我使用了动画 Animate.css,请自行体验 这个项目中,我把我能实现的都实现了,后续有时间可以继续增加功能. 整个项目中多次使用了播放事件,我就用provide/inject来实现多次调用，在App.vue页面中实现playaudio事件 reload和iffooter方法是别的方法,可以忽略 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071provide() &#123; return &#123; reload: this.reload, iffooter: this.iffooter, playaudio(id) &#123; setTimeout(() =&gt; &#123; let audio = document.getElementsByClassName("audio")[0]; let playicon = document.getElementById("playicon"); // 同一次点击时,根据状态是否播放 if (audio.src == this.$store.state.src) &#123; if (audio.paused) &#123; audio.play(); playicon.innerHTML = "&amp;#xe68e;"; this.$toast.success("开始播放"); &#125; else &#123; audio.pause(); playicon.innerHTML = "&amp;#xe612;"; this.$toast.fail("暂停播放"); &#125; &#125; else &#123; audio.src = this.$store.state.src; if (audio !== null) &#123; if (audio.paused) &#123; let playpromise = audio.play(); if (playpromise) &#123; playpromise .then(() =&gt; &#123; setTimeout(() =&gt; &#123; playicon.innerHTML = "&amp;#xe68e;"; this.$toast.success("开始播放"); &#125;, 2000); &#125;) .catch(err =&gt; &#123; console.log(err); this.$notify(&#123; type: "danger", message: "该资源无法加载,请选择别的歌曲" &#125;); &#125;); &#125; // 数字变成字符串 let gid = id.toString(); //把播放过的歌曲id 存入sessionStorage //防止页面刷新后vuex里面的数据消失 if (this.$store.state.songid.length == 0) &#123; this.$store.state.songid = JSON.parse( sessionStorage.getItem("songid") ); &#125; //点击同一首歌，不添加 if (this.$store.state.songid.indexOf(gid) == -1) &#123; this.$store.state.songid.push(gid); let songid = JSON.stringify(this.$store.state.songid); sessionStorage.setItem("songid", songid); &#125; // 保存播放的id this.$store.state.current = gid; let current = JSON.stringify(this.$store.state.current); sessionStorage.setItem("current", current); this.iffooter(); &#125; else &#123; audio.pause(); playicon.innerHTML = "&amp;#xe612;"; this.$toast.fail("暂停播放"); &#125; &#125; &#125; &#125;, 600); &#125; &#125;; &#125;, 底部播放栏在App.vue里面调用,会根据用户当前播放的歌曲进行调整,点击图标可以进入歌曲详情，查看歌词 底部栏每次都显示当前播放的信息 songid为每次用户点击播放歌曲,就会把歌曲id存入到sessionStoragecurrent为当前播放的歌曲id也存入到sessionStorage 1234567891011121314151617// 获取信息 getimg() &#123; // 默认 if (JSON.parse(sessionStorage.getItem("songid")).length == 0) &#123; this.$refs.img.src = "https://hexophoto-1259178461.cos.ap-beijing.myqcloud.com/photos/6.jpg"; this.$refs.name.innerHTML = "请播放歌曲!"; &#125; else &#123; // 显示当前播放歌曲信息 this.current = JSON.parse(sessionStorage.getItem("current")); // 获取歌曲信息 this.axios.get("/song/detail?ids=" + this.current).then(res =&gt; &#123; this.detail = res.data.songs[0]; this.imgurl = this.detail.al; &#125;); &#125; &#125; 登录,注册(手机号登录,信息存入sessionStorage和Vuex)登录账号是网易云的账号 12345678910111213141516171819202122232425262728userlogin() &#123; if (this.phone == "" || this.password == "") &#123; this.$dialog.alert(&#123; message: "手机号或者密码不能为空!" &#125;); &#125; else &#123; this.axios .get( "/login/cellphone?phone=" + this.phone + "&amp;password=" + this.password ) .then(res =&gt; &#123; this.$store.state.uid = res.data.account.id; // 存入sessionStorage 防止刷新数据消失 let id = JSON.stringify(res.data.account.id); sessionStorage.setItem("uid", id); this.$dialog .alert(&#123; message: "登录成功!" &#125;) .then(() =&gt; &#123; this.$router.push("/sheet"); &#125;); &#125;); &#125; &#125;, 注册使用了验证码,在注册前要判断验证码是否正确,其次对于已经注册过账号的手机号，直接跳到login页面 歌单(热门，推荐，收藏)歌单的详情基本都是一样的，我使用了一个组件来完成 Detail.vue,该页面主要展示歌单里面的歌曲,点击可以播放,收藏歌单在登录用户后,点击用户信息可以看到。 歌手(歌手榜)我使用了三个组件 sheet.vue ranking.vue singer.vue 来组成首页的三个部分,歌手榜用的是热门歌手数据。所以有的歌手看不到请见谅！歌手详情有五个子页面。当时做的时候本来四个就好了，结果不知道什么原因，展示的第一个页面,在从父页面获取id后，能够打印出来，但是在发送请求axios时，id就变成undefined了,我没有找到其他好的解决方法，就多加了个无关紧要的页面解决这个BUG. 歌词(歌词滚动,进度条拖动)因为把audio放在了app.vue上面,我在歌词页面使用了vuex来就行管理. 进度条在用ref来获取audio时，发现获取不了，就直接用原生的JS来获取了,许多位置我都是用原生来获取的。 1234567891011121314151617181920212223export default new Vuex.Store(&#123; state: &#123; // 判断底部播放是否加载 footer: true, showfooter: true, // 登录信息 uid: 0, // 歌曲id songid: [], // 歌曲资源 src: "1", audio: &#123; //当前播放时间 currentTime: 0, // 歌曲总长 maxTime: 0 &#125;, // 进度条 playtime: 0, // 当前播放音乐ID current: "" &#125;&#125; 在App.vue页面 12345678910&lt;template&gt; &lt;div id="app"&gt; &lt;audio class="audio" ref="audio" @timeupdate="onTimeupdate" @loadedmetadata="onLoadedmetadata" &gt;&lt;/audio&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617export default &#123; // 记录播放时间 onTimeupdate(res) &#123; // 获取当前播放时间 this.$store.state.audio.currentTime = res.target.currentTime; // 获取进度条进度 this.$store.state.playtime = parseInt( (this.$store.state.audio.currentTime / this.$store.state.audio.maxTime) * 100 ); &#125;, // 获取歌曲总时长 onLoadedmetadata(res) &#123; this.$store.state.audio.maxTime = parseInt(res.target.duration); &#125;,&#125; 点击进度条事件 123456789101112click(res) &#123; let audio = document.getElementsByClassName("audio")[0]; // 当前点击距离 let clicktime = res.clientX; // 进度条距离 this.playtime = parseInt((clicktime / 375) * 100); // 更新播放时间 audio.currentTime = parseInt( (this.playtime * this.$store.state.audio.maxTime) / 100 ); this.setroll(); &#125;, 搜索点击搜索进入热门搜索,会根据当时的热度进行排行,再次点击会显示搜索结果,可以直接进行播放. 总结在两个星期内做完了这个感觉还是比较有收获的,之前对audio一点了解都没有,现在不会像之前那样一窍不通了,在各种组件传值,调用方法方面也有了不少的进步,对vue也有了进一步的了解,希望在以后能够继续加油。]]></content>
      <categories>
        <category>web前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vant</tag>
        <tag>NeteaseCloudMusicApi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts的使用方法]]></title>
    <url>%2Fyqxshiki.github.io%2Fecharts%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[ECharts的介绍 ECharts，缩写来自 Enterprise Charts，商业级数据图表，是百度的一个开源的数据可视化工具，一个纯 Javascript 的图表库，能够在 PC 端和移动设备上流畅运行，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），底层依赖轻量级的 Canvas 库 ZRender，ECharts 提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力 ECharts官网点击进入 无框架在HTML页面中使用引入Echarts1&lt;script src="https://cdn.bootcss.com/echarts/4.3.0-rc.2/echarts-en.common.js"&gt;&lt;/script&gt; 绘制一个DOM容器1&lt;div id="myChart" style="width:100%;height:400px;"&gt;&lt;/div&gt; 初始化Echarts实例1let myChart = echarts.init(document.getElementById("myChart")); 配置图表的配置项个数据123myChart.setOption(&#123;&#125;) 或者 1234let opation=&#123;&#125;myChart.setOption(option); Vue中使用先npm安装Echarts1npm install echarts --save 引入Echarts可分为部分引入和全局引入 部分引入在需要使用Echarts图表的vue文件里面导入 1import echarts from 'echarts' 全局引入在main.js中引入,这样就可以再每个vue文件里面使用不需要每一个都引入。 12import echarts from 'echarts'Vue.prototype.echarts = echarts 绘制DOM容器1&lt;div id="myChart" :style="&#123;width: '300px', height: '300px'&#125;"&gt;&lt;/div&gt; 在methods中写实现方法12345678910methods: &#123; drawLine( //初始化化Echarts实例 let myChart = this.echarts.init(document.getElementById("myChart")); //配置图表数据和配置项 myChart.setOption(&#123; //放数据 &#125;) )&#125; 在页面渲染完成前展示123mounted() &#123; this.drawLine();&#125;,]]></content>
      <categories>
        <category>web前端</category>
        <category>图表</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS拖拽事件]]></title>
    <url>%2Fyqxshiki.github.io%2F%E5%8E%9F%E7%94%9FJS%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入本人Blog(国外)：点击进入 拖拽对象必须的有定位的12345678910.app &#123; width: 100px; height: 100px; background: red; /* margin: 20px; */ position: absolute; border: 10px solid black; cursor: move;&#125;&lt;div class="app"&gt;&lt;/div&gt; 当对象加了margin后app.offsetWidth,app.offsetHeight是不包括margin的，所以会出现有一段空白区不能移动 拖拽事件为分为三部分组成 鼠标按下 鼠标移动 鼠标松开 window.onload = function () { let app = document.getElementsByClassName("app")[0]; // console.log(app); ​ // 鼠标按下 app.onmousedown = function (e) { // console.log(e.clientX, e.clientY) // 这是 鼠标落下的点 =&gt; 游览器的可视区域的距离(不包括工具栏和滚动条) ​ // console.log(app.offsetLeft, app.offsetTop); // 这是 对象app的margin =&gt; 最近有定位的父级padding的距离(没有定位就到文档的距离) ​ let disx = e.clientX - app.offsetLeft; disy = e.clientY - app.offsetTop; // console.log(disx, disy) // disx disy 就是 鼠标落下的点到 =&gt;对象app的边框距离 ​ // 鼠标移动 document.onmousemove = function (e) { let movex = e.clientX - disx; let movey = e.clientY - disy; // movex movey 就是移动后 对象app的margin =&gt; 浏览器可视区域的距离 ​ if (movex &lt; 0) { movex = 0; } else if (movex &gt; window.innerWidth - app.offsetWidth) { movex = window.innerWidth - app.offsetWidth } if (movey &lt; 0) { movey = 0; } else if (movey &gt; window.innerHeight - app.offsetHeight) { movey = window.innerHeight - app.offsetHeight } // 不超出边界 ​ let lefts = app.style.left = movex + "px"; let tops = app.style.top = movey + "px"; // console.log(lefts, tops) } ​ // 鼠标松开 document.onmouseup = function () { // 取消鼠标之前的操作 this.onmousemove = null; this.onmousedown = null; } } }]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台管理系统 vue-admin-webapp]]></title>
    <url>%2Fyqxshiki.github.io%2F%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fvue-admin-webapp.html</url>
    <content type="text"><![CDATA[这个本人第一次做比较大的项目,结合许多知识来完成项目,代码可能不怎么好看,优化也不行,请见谅。在之后我会继续提交的我的实力。因为我还是初学前端不到一年，如果下面的有所错误请提出来我会修改。 vue-admin-webapp看了掘金一篇文章后，仿照别人的demo自己做的一个vue后台管理系统 掘金原文章地址 本人Blog(国内)：点击进入本人Blog(国外)：点击进入 本项目涉及的技术栈有vuevue-cli vue-Router axios Echarts element-ui fastmock webpack 本项目github地址vue-admin-webapp 项目运行地址vue-admin-webapp 项目简介vue-admin-webapp 是一个后台管理系统,基于vuecli 和element-ui,使用fastmock来模拟数据,其中有图表,表格,权限,excel等等，你可以根据你的需求来添加路由。 安装123456789101112# 克隆项目git clone git@github.com:yqxshiki/vue-admin-webapp.git# 进入项目目录cd vue-admin-webapp# 安装依赖npm install# 启动服务npm run serve 启动后，将自动打开游览器 http://localhost:8080,你就可以看到项目效果了。 项目页面结构 出去登录页,页面主要来三个部分组成：头部 侧边栏 展示页,可以点击侧边栏来就行路由跳转 登录权限验证从fastmock中接收token,登录时存储在localStorage,设置全局前置守卫,在进入其他页面时，有token时才能进入，不然就跳到login页面 全局前置守卫12345678router.beforeEach((to, from, next) =&gt; &#123; const isLogin = localStorage.loginToken ? true : false; if (to.path == "/login") &#123; next(); &#125; else &#123; isLogin ? next() : next('/login') &#125;&#125;) 请求拦截12345678910axios.interceptors.request.use(config =&gt; &#123; // 判断是否有token if (localStorage.loginToken) &#123; config.headers.Authorization = localStorage.loginToken; &#125; return config;&#125;, err =&gt; &#123; // 请求错误 return Promise.reject(err);&#125;) 响应拦截12345678910111213141516axios.interceptors.response.use(res =&gt; &#123; return res;&#125;, err =&gt; &#123; const &#123; status &#125; = err.response; if (status == 401) &#123; // 后台定义401为过期 alert("token过期,请重新登录!") // 清楚token localStorage.removeItem("loginToken"); router.push("/login"); &#125; else &#123; alert(err.response.data) &#125; return Promise.reject(err); &#125;); Echart多图表会熟练运用Echart,直线图，饼图，柱状图，动态数据图等等,例如下图 Excel excel在实际项目中主要是后端做的，当然前端也可以做,只是我觉得现在没有必要所以没做。想了解的可以去搜索一下就有。 fastmock数据这里引用官方的介绍 fastmock可以让你在没有后端程序的情况下能真实地在线模拟ajax请求，你可以用fatmock实现项目初期纯前端的效果演示，也可以用fastmock实现开发中的数据模拟从而实现前后端分离。在使用fastmock之前，你的团队实现数据模拟可能是下面的方案中的一种或者多种 本地手写数据模拟，在前端代码中产生一大堆的mock代码。 利用mockjs或者canjs的can-fixture实现ajax拦截，本地配置必要的json规则。 后端在Controller层造假数据返回给前端。 我的fastmock 项目端口]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Javascript</tag>
        <tag>echart</tag>
        <tag>fastmock</tag>
        <tag>element-ui</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 vue后台管理系统 element-ui 分页]]></title>
    <url>%2Fyqxshiki.github.io%2Fvue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Felement-ui%E5%88%86%E9%A1%B5.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 vue-admin-webapp项目运行地址点击进入 github地址 Element-uiElement，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 element-ui 中文官网点击进入 我自己做的vue-admin-webapp项目中的源码 1234567891011121314151617181920212223242526272829&lt;el-table :data="pagingtable.slice((currentPage - 1) * pagesize, currentPage * pagesize)" border style="width: 100%"&gt; &lt;el-table-column prop="order" label="序号"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="gid" label="ID"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="产品名称"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="price" label="价格"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="number" label="数量"&gt;&lt;/el-table-column&gt; &lt;el-table-column width="120" prop="tag" label="状态"&gt; &lt;template slot-scope="scope"&gt; &lt;el-tag :type="scope.row.tag =='已取消' ? 'danger':'success' " disable-transitions &gt;&#123;&#123;scope.row.tag&#125;&#125;&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt;&lt;el-pagination @size-change="handleSizeChange" @current-change="handleCurrentChange" :current-page="currentPage" :page-sizes="[5, 10, 15, 20]" :page-size="pagesize" layout="total, sizes, prev, pager, next, jumper" :total="pagingtable.length" &gt;&lt;/el-pagination&gt; &lt;!-- total是总数据量 --&gt; 123456789101112131415161718192021222324252627282930313233343536export default &#123; data() &#123; return &#123; pagingtable: [], //把接收到的数据存储到这里 pagesize: 5, //页面一次展示多少数据 currentPage: 1 // 第几页 &#125;; &#125;, methods: &#123; // 每页展示多少条数据 handleSizeChange(size) &#123; this.pagesize = size; &#125;, // 第几页 handleCurrentChange(currentPage) &#123; this.currentPage = currentPage; &#125;, // 获取数据 getorder() &#123; this.axios .get("/api/order") .then(res =&gt; &#123; // console.log(res); this.pagingtable = res.data.data.table; // console.log(this.pagingtable.length); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; &#125;, // 页面渲染前拿到数据 mounted() &#123; this.getorder(); &#125;&#125;; 效果显示]]></content>
      <categories>
        <category>web前端</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 vue后台管理系统driver.js蒙版引导]]></title>
    <url>%2Fyqxshiki.github.io%2Fvue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fdriver.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 vue-admin-webapp项目运行地址点击进入 github地址 driver.js介绍driver.js 蒙版引导,也就是我们经常第一次使用时,会引导你正确使用该项目的功能 简单：易于使用，完全没有外部依赖性 轻量级：〜4kb大小，原始JavaScript，无外部依赖 高度可定制：具有强大的API，可以根据需要使用 突出显示任何内容：突出显示页面上的任何（字面上是任何）元素 功能介绍：为您的Web应用程序创建功能强大的功能介绍 安装1npm install driver.js 使用方法12345&lt;template&gt; &lt;div id="driver"&gt; &lt;div @click="guide()"&gt;引导&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425// 引用库import Driver from "driver.js";import "driver.js/dist/driver.min.css";// 新建一个guide.js 引人import steps from "./guide";export default &#123; mounted() &#123; this.driver = new Driver(&#123; opacity: 0.5,//透明度 animate: true,//动画 padding: 10,//边距 allowClose: true,//点击覆盖是否应该关闭 overlayClickNext: false,//单击覆盖是否应移动到下一步 doneBtnText: "完成", closeBtnText: "关闭", nextBtnText: "下一步", prevBtnText: "上一步" &#125;); &#125;, methods: &#123; guide() &#123; this.driver.defineSteps(steps); this.driver.start(); &#125; &#125; 新建的guide.js 123456789101112131415161718192021222324252627282930313233343536const steps = [ &#123; element: '#sidebar',//绑定元素,不要用class,id具有唯一性,比较好 popover: &#123; title: '折叠按钮',//标题 description: '点击收缩和展开菜单导航',//内容 position: 'bottom'//显示位置 &#125; &#125;, &#123; element: '#domshouye', popover: &#123; title: '面包屑导航', description: '用于显示当前菜单的位置', position: 'bottom-right' &#125; &#125;, &#123; element: '#domMessage', popover: &#123; title: '通知', description: '点击图标，右侧会显示通知消息', position: 'bottom-right' &#125; &#125;, &#123; element: '#domFullScreen', popover: &#123; title: '全屏显示', description: '点击图标，放大全屏显示系统', position: 'bottom-right' &#125; &#125;,]export default steps 效果显示 更加详细的内容可以去官网查看点击进入]]></content>
      <categories>
        <category>web前端</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 vue后台管理系统-vue-count-to 数字滚动插件]]></title>
    <url>%2Fyqxshiki.github.io%2Fvue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fvue-count-to.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 vue-admin-webapp项目运行地址点击进入 github地址 vue-count-to 数字滚动插件在做vue-admin-webapp项目中,首页就是有数字滚动效果,它是一个无依赖项的轻量级vue组件。 安装1npm install vue-count-to 使用方法123&lt;template&gt; &lt;count :startvalue='startvalue' :endvalue='endvalue' :duration='3000'&gt;&lt;/count&gt;&lt;/template&gt; 1234567891011121314&lt;script&gt; import count from 'vue-count-to'; export default &#123; components: &#123; count &#125;, data () &#123; return &#123; startvalue: 0, endvalue: 2017 &#125; &#125; &#125;&lt;/script&gt; startvalue:开始值endvalue:结束值duration：持续时间 效果显示 还有不少属性可以调整，可以去vue-count-to学习]]></content>
      <categories>
        <category>web前端</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-bash基础命令行使用]]></title>
    <url>%2Fyqxshiki.github.io%2Fgit-bash.html</url>
    <content type="text"><![CDATA[在注册使用了github后，我们也应该学会使用git 来提交管理代码 本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 git介绍是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 git常用命令 配置git 用户名和密码 123git config --global user.name xxx(用户名)git confit --global user.email xxx(邮箱) 查看当前git的配置 1git config --list 初始化git 仓库 1git init 查看当前仓库的状态 1git status 将需要提交的代码文件添加的暂存区 123git add xxx(文件名)git add xxx(文件名) xxx(文件名) 上传多个文件时中间用空格分开git add . (.是提交当前文件夹内的所有文件) 将暂存区中的代码提交到本地仓库，形成一个版本 1git commit -m &quot;备注&quot; 查看本地仓库中的历史提交版本 1git log 将暂存区中文件删除 1git rm --cached xxx(文件名) 用暂存区中的文件覆盖工作目录中的文件 1git checkout --xxx(文件名) 回滚到本地仓库中特定版本并覆盖暂存区和工作目录 123git reset --hard commitID(commitID可以到git log中查看提交编号)如果有版本1，版本2（后提交），当回滚到版本1时版本2会被自动删除。 git 分支相关命令 查看分支 1git branch 创建分支 1git branch xxx(分支名) 切换分支 1git checkout xxx(分支名) 创建并切换分支 1git checkout -b xxx(分支名) 删除分支 1git branch -d xxx(分支名) 强制删除分支 1git branch -D xxx(分支名) 合并分支 1git merge xxx(需要当前主分支上，合并的分支名) git 相关命令 从远程仓库获取代码（拉取所有版本到本地） 1git clone origin 从远程仓库拉取代码（拉取最新版本到本地，开发过程中使用） 1git pull origin master 向远程仓库推送代码 123git push origin master(本地分支名称)：master(远程分支名称)如果本地分支同远程分支名称一样，可以只写一个 删除当前别名所对应的远程仓库地址 1git remote remove origin]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解px rpx em rem vw wh]]></title>
    <url>%2Fyqxshiki.github.io%2Fpixel.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 pxpx是pixel的缩写,像素是指基本原色素及其灰度的基本编码。px是相对长度单位，在一般的开发情况下，我们选择px，但是并不是所有情况都用px来解决问题 rpxrpx主要收用于在做微信小程序开发时用到的一种单位,它能够在不同手机上面自适应屏幕尺寸. 在css中px 为css像素也叫逻辑像素;设备像素是设备屏幕的物理像素，任何设备的物理像素的数量都是固定的, DPRDPR是设备像素比,在默认缩放为100%的情况下，设备像素和逻辑像素的比值.iphone 6的设备像素为750，而iphone 6的逻辑像素为375 dpr =2,也就是1px =2rpx,因此我们经常在微信小程序里面用iphone 6当模板进行开发. emem也是相对长度单位，相对于对象文字的字体大小，如果没有设置，则默认为浏览器的默认字体大小. em的值是自己字体大小，如果没有设置就是继承父级元素的字体大小，依次向上找，如果打没有设置就是浏览器默认字体大小 remrem 是css3中新增的 (root em)，和em类似都是字体大小。但是它是相对HTML根元素的。当改变根元素的字体大小时，可以同时更改所有的字体大小。 vw–vhvw和vh是视口单位(viewport),就是依据浏览器窗口大小的单位。 1vw=可视窗口的宽度 * 1% 。 1vh=可视窗口的高度 * 1% 。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue初识--vue常用指令]]></title>
    <url>%2Fyqxshiki.github.io%2FVue%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Vue介绍本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 Vue 是目前主流前端三大框架之一，是一套渐进式框架。他的作者是一位华人-尤雨溪，有中文官方文档Vue中文官方文档 在这里我们选择用CDN的方式来引入 1&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; Vue实例每一个Vue都是通过new Vue开始的 123456789101112let vm =new Vue(&#123; el:"", data:&#123; &#125;, methods:&#123; &#125;, computed:&#123; &#125;&#125;) 在HTML中我们可以使用 这种来插值. v-ifv-if 绑定的值在data中定义,根据定义值的真假来插入或者移除元素 1234567891011&lt;div id="app"&gt; &lt;p v-if="scok"&gt;你能看到我吗？&lt;/p&gt;&lt;/div&gt; let vm =new Vue(&#123; el:"#app", data: &#123; scok:true &#125;&#125;) 当 scok的值为 false null undefined 0 时，都不显示,为移除元素。 v-showv-show 和v-if相识 都是通过判断boolean 来显示或者不显示元素,当定义的值为 false null undefined 0是 ,不显示 12345678910&lt;div id="app"&gt;&lt;p v-show="msg"&gt;你猜你看得到我吗？&lt;/p&gt;&lt;/div&gt;let vm =new Vue(&#123; el:"#app", data:&#123; msg: null &#125;&#125;) v-show 和 v-if 的区别v-show 当不显示时 可以看到是用css 将display:none; 来就行隐藏 v-show 安全性不高，主要用于特殊类型的切换【显示与隐藏】,不适合做后台管理系统 而v-if 本质是移除Dom节点适合后台管理系统安全性比较高 v-modelv-model是数据双向绑定 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="msg"&gt; &#123;&#123;msg&#125;&#125; &lt;hr&gt; &lt;input type="checkbox" name="checkbox" v-model="list"&gt; &#123;&#123;list&#125;&#125; &lt;hr&gt; &lt;input type="radio" value="true" name="radio" v-model="radio"&gt; &lt;label for=""&gt;true&lt;/label&gt; &lt;input type="radio" value="false" name="radio" v-model="radio"&gt; &lt;label for=""&gt;false&lt;/label&gt; &#123;&#123;radio&#125;&#125; &lt;hr&gt; &lt;input type="checkbox" value="apple" v-model="checkboxlist"&gt; &lt;input type="checkbox" value="orange" v-model="checkboxlist"&gt; &lt;input type="checkbox" value="Banana" v-model="checkboxlist"&gt; &#123;&#123;checkboxlist&#125;&#125; &lt;hr&gt; &lt;select v-model="array"&gt; &lt;option&gt;a&lt;/option&gt; &lt;option&gt;b&lt;/option&gt; &lt;option&gt;c&lt;/option&gt; &lt;option&gt;d&lt;/option&gt; &lt;/select&gt; &#123;&#123;array&#125;&#125;&lt;/div&gt; let vm =new Vue(&#123; el:"#app", data:&#123; msg:"", list:true radio:[], checkboxlist: [], array:[] &#125;&#125;) 通过v-model绑定,当用户在input框中输入数据时,会通过 显示出来 当是单选框时要注意，绑定的值要是数组[] 多个复选框时,绑定的值也要是数组[] 下拉列表时,绑定的值也要是数组[] ———————-持续更新中———————-]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用git github hexo 搭建属于自己的个人博客]]></title>
    <url>%2Fyqxshiki.github.io%2Fhexo.html</url>
    <content type="text"><![CDATA[本人Blog(国内)：点击进入 本人Blog(国外)：点击进入 1 安装git之前在学数据库的时候，用的是windows系统,在cmd中敲命令,用得不是很舒服，安装git 下载地址：git 安装：一路next就行 安装好后：打开Git Bash 输入： git version 这样就安装好了 2 安装nodenode是JavaScript的运行环境,其中npm是包管理工具，在之后我们需要利用npm下载一系列的东西 下载地址：node 安装：一路next就行,但在Custom Setup这一步记得选 Add to PATH 安装好后：打开cmd 输入： node -v 这样就安装好了 3 安装hexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 先创建一个文件夹，打开git bash ，然后cd到当前文件夹,运行 这是在全局安装hexocnpm install -g hexo-cli初始化项目 下载需要相应的文件hexo init cnpm install完成以后在文件夹中会获得不少文件 4 和github关联没有注册github的点击这里github,注册一个账号，然后创建一个存储库 在输入Repository name时要注意,名字要与你的github用户名一样，例如：yqxshiki.github.io,前面是你自己的名字后面加上 .github.io ———————-持续更新中———————-]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
